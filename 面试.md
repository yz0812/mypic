# 基础



# Java基础

#### 1. Object类中有哪些方法

equals()、toString()、finalize()、hashCode()、getClass()、clone()、wait()、notify()、notifyAll()

#### 2.hashCode和equals方法的关系

**equals** 用于判断其他对象是否与该对象相同

**hashCode** 

>  重点

hashCode() 的作用是获取哈希码，也称为散列码;它实际上是返回一个 int 整数。这个哈希码的作用 是确定该对象在哈希表中的索引位置。hashCode() 定义在 JDK 的 Object.java 中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。

散列表存储的是键值对(key-value)，它的特点是:能根据“键”快速的检索出对应的“值”。这其中就利 用到了散列码!(可以快速找到所需要的对象)

1. 如果两个对象相等，则 hashcode 一定也是相同的
2. 两个对象相等,对两个对象分别调用 equals 方法都返回 true
3. 两个对象有相同的 hashcode 值，它们也不一定是相等的
4. 因此，**equals** 方法被覆盖过，则 **hashCode** 方法也必须被覆盖
5. hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class   的两个对象无论如何都不会相等(即使这两个对象指向相同的数据)

#### 3.HashMap

##### 3.1存储结构

我们现在用的都是 JDK 1.8，底层是由“数组+链表+红黑树”组成，如下图，而在 JDK 1.8 之前是由“数组+链表”组成。

##### 3.2. 为什么要改成“数组+链表+红黑树”？

主要是为了提升在 hash 冲突严重时（链表过长）的查找性能，使用链表的查找性能是 O(n)，而使用红黑树是 O(logn)。

##### 3.3.那在什么时候用链表？什么时候用红黑树？

对于插入，默认情况下是使用链表节点。当同一个索引位置的节点在新增后达到9个（阈值8）：如果此时数组长度大于等于 64，则会触发链表节点转红黑树节点（treeifyBin）；而如果数组长度小于64，则不会触发链表转红黑树，而是会进行扩容，因为此时的数据量还比较小。

对于移除，当同一个索引位置的节点在移除后达到 6 个，并且该索引位置的节点为红黑树节点，会触发红黑树节点转链表节点（untreeify）。

##### 3.4  HashMap 有哪些重要属性？分别用于做什么的？

 除了用来存储我们的节点 table 数组外，HashMap 还有以下几个重要属性：

1）size：HashMap 已经存储的节点个数；

2）threshold：扩容阈值，当 HashMap 的个数达到该值，触发扩容。

3）loadFactor：负载因子，扩容阈值 = 容量 * 负载因子。

##### 3.5threshold 除了用于存放扩容阈值还有其他作用吗？

在我们新建 HashMap 对象时， threshold 还会被用来存初始化时的容量。HashMap 直到我们第一次插入节点时，才会对 table 进行初始化，避免不必要的空间浪费。

##### 3.6 HashMap 的默认初始容量是多少？HashMap 的容量有什么限制吗？

默认初始容量是16。HashMap 的容量必须是2的N次方，HashMap 会根据我们传入的容量计算一个大于等于该容量的最小的2的N次方，例如传 9，容量为16。

容量为16，可以利用&运算符，快速定位到key所在数组的位置，使put和get更高效。

##### 3.7你说 HashMap 的默认初始容量是 16，为什么是16而不是其他的？

我认为是16的原因主要是：16是2的N次方，并且是一个较合理的大小。如果用8或32，我觉得也是OK的。实际上，我们在新建 HashMap 时，最好是根据自己使用情况设置初始容量，这才是最合理的方案。

#####  3.8刚才说的负载因子默认初始值又是多少？为什么是0.75而不是其他的？

这个也是在时间和空间上权衡的结果。如果值较高，例如1，此时会减少空间开销，但是 hash 冲突的概率会增大，增加查找成本；而如果值较低，例如 0.5 ，此时 hash 冲突会降低，但是有一半的空间会被浪费，所以折衷考虑 0.75 似乎是一个合理的值。

#####  3.9 HashMap 是线程安全的吗？

不是。HashMap 在并发下存在数据覆盖、遍历的同时进行修改会抛出 ConcurrentModificationException 异常等问题，JDK 1.8 之前还存在死循环问题。

#####  3.10 介绍一下死循环问题？

导致死循环的根本原因是 JDK 1.7 扩容采用的是“头插法”，会导致同一索引位置的节点在扩容后顺序反掉。而 JDK 1.8 之后采用的是“尾插法”，扩容后节点顺序不会反掉，不存在死循环问题。

##### 3.11 那总结下 JDK 1.8 主要进行了哪些优化？

1）底层数据结构从“数组+链表”改成“数组+链表+红黑树”，主要是优化了 hash 冲突较严重时，链表过长的查找性能：O(n) -> O(logn)。

2）计算 table 初始容量的方式发生了改变，老的方式是从1开始不断向左进行移位运算，直到找到大于等于入参容量的值；新的方式则是通过“5个移位+或等于运算”来计算。

3）优化了 hash 值的计算方式，老的通过一顿瞎JB操作，新的只是简单的让高16位参与了运算。

4）扩容时插入方式从“头插法”改成“尾插法”，避免了并发下的死循环。

5）扩容时计算节点在新表的索引位置方式从“h & (length-1)”改成“hash & oldCap”，性能可能提升不大，但设计更巧妙、更优雅。

#####  3.12 put(key,value)存放数据的过程，主要有2步

1. 步骤1：确定(key,value)需要放在数组的什么位置？
2. 步骤2：将放进来的数据放在链表中头部



##### 3.13 get(key)查找数据的过程，主要有2步

步骤1：确定key对应的数据在数组的什么位置？
步骤2：沿着链表一个个查找，直到找到对应的key为止

#### 5.设计模式

##### 5.1 设计原则

1. 单一原则 : 一个类或一个方法只负责一件事情

2. 里斯替换原则: 子类不应该重写父类已实现的方法,重载不应该比父类的参数更少

3. 依赖倒置原则: 面向接口编程.（面向接口更能添加程序的可扩展性）

4. 接口隔离原则: 接口中的方法应该细分,要合理的隔离开不同的功能到不同的接口中.

5. 迪米特原则: 高内聚低耦合

6. 开闭原则: 对修改关闭，对扩展开放

7. 组合/聚合复用原则 尽量使用组合和聚合少使用继承的关系来达到复用的原则。

##### 5.2设计模式

##### 1.说一下设计模式？你都知道哪些？

答：设计模式总共有 23 种，总体来说可以分为三大类：创建型模式（ Creational Patterns ）、结构型模式（ Structural Patterns ）和行为型模式（ Behavioral Patterns ）。

##### 2.什么是单例模式？
答：单例模式是一种常用的软件设计模式，在应用这个模式时，单例对象的类必须保证只有一个实例存在，整个系统只能使用一个对象实例。

优点：不会频繁地创建和销毁对象，浪费系统资源。

使用场景：IO 、数据库连接、Redis 连接等。



#####  3.什么是简单工厂模式？

答：简单工厂模式又叫静态工厂方法模式，就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。比如，一台咖啡机就可以理解为一个工厂模式，你只需要按下想喝的咖啡品类的按钮（摩卡或拿铁），它就会给你生产一杯相应的咖啡，你不需要管它内部的具体实现，只要告诉它你的需求即可。

**优点**：

- 工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象；
- 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量；
- 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。

**缺点**：

- 不易拓展，一旦添加新的产品类型，就不得不修改工厂的创建逻辑；
- 产品类型较多时，工厂的创建逻辑可能过于复杂，一旦出错可能造成所有产品的创建失败，不利于系统的维护。

#####  4.什么是装饰器模式？

答：装饰器模式是指动态地给一个对象增加一些额外的功能，同时又不改变其结构。

优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。

装饰器模式的关键：装饰器中使用了被装饰的对象。

比如，创建一个对象“laowang”，给对象添加不同的装饰，穿上夹克、戴上帽子......，这个执行过程就是装饰者模式，实现代码如下。

##### 5.什么是抽象工厂模式？

答：抽象工厂模式是在简单工厂的基础上将未来可能需要修改的代码抽象出来，通过继承的方式让子类去做决定。

比如，以上面的咖啡工厂为例，某天我的口味突然变了，不想喝咖啡了想喝啤酒，这个时候如果直接修改简单工厂里面的代码，这种做法不但不够优雅，也不符合软件设计的“开闭原则”，因为每次新增品类都要修改原来的代码。这个时候就可以使用抽象工厂类了，抽象工厂里只声明方法，具体的实现交给子类（子工厂）去实现，这个时候再有新增品类的需求，只需要新创建代码即可。

#####  6.什么是模板方法模式？

答：模板方法模式是指定义一个模板结构，将具体内容延迟到子类去实现。

**优点**：

- 提高代码复用性：将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中；
- 实现了反向控制：通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制并且符合开闭原则。

以给冰箱中放水果为例，比如，我要放一个香蕉：开冰箱门 → 放香蕉 → 关冰箱门；如果我再要放一个苹果：开冰箱门 → 放苹果 → 关冰箱门。可以看出它们之间的行为模式都是一样的，只是存放的水果品类不同而已，这个时候就非常适用模板方法模式来解决这个问题，实现代码如下：



##### 7.什么是代理模式？

代理模式是给某一个对象提供一个代理，并由代理对象控制对原对象的引用。

**优点**：

- 代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度；
- 可以灵活地隐藏被代理对象的部分功能和服务，也增加额外的功能和服务。

**缺点**：

- 由于使用了代理模式，因此程序的性能没有直接调用性能高；
- 使用代理模式提高了代码的复杂度。

举一个生活中的例子：比如买飞机票，由于离飞机场太远，直接去飞机场买票不太现实，这个时候我们就可以上携程 App 上购买飞机票，这个时候携程 App 就相当于是飞机票的代理商。

#####  8.什么是策略模式？

答：策略模式是指定义一系列算法，将每个算法都封装起来，并且使他们之间可以相互替换。

**优点**：遵循了开闭原则，扩展性良好。

**缺点**：随着策略的增加，对外暴露越来越多。

以生活中的例子来说，比如我们要出去旅游，选择性很多，可以选择骑车、开车、坐飞机、坐火车等，就可以使用策略模式，把每种出行作为一种策略封装起来，后面增加了新的交通方式了，如超级高铁、火箭等，就可以不需要改动原有的类，新增交通方式即可，这样也符合软件开发的开闭原则。 策略模式实现代码如下：



##### 9.什么是适配器模式？

答：适配器模式是将一个类的接口变成客户端所期望的另一种接口，从而使原本因接口不匹配而无法一起工作的两个类能够在一起工作。

**优点**：

- 可以让两个没有关联的类一起运行，起着中间转换的作用；
- 灵活性好，不会破坏原有的系统。

**缺点**：过多地使用适配器，容易使代码结构混乱，如明明看到调用的是 A 接口，内部调用的却是 B 接口的实现。

以生活中的例子来说，比如有一个充电器是 MicroUSB 接口，而手机充电口却是 TypeC 的，这个时候就需要一个把 MicroUSB 转换成 TypeC 的适配器，如下图所示：

##### 10.Spring 中都使用了哪些设计模式？

代理模式：在 AOP 中有使用
单例模式：bean 默认是单例模式
模板方法模式：jdbcTemplate
工厂模式：BeanFactory
观察者模式：Spring 事件驱动模型就是观察者模式很经典的一个应用，比如，ContextStartedEvent 就是 ApplicationContext 启动后触发的事件
适配器模式：Spring MVC 中也是用到了适配器模式适配 Controller



##### 11.IO 使用了什么设计模式？

答：IO 使用了适配器模式和装饰器模式。

- 适配器模式：由于 InputStream 是字节流不能享受到字符流读取字符那么便捷的功能，借助 InputStreamReader 将其转为 Reader 子类，因而可以拥有便捷操作文本文件方法；
- 装饰器模式：将 InputStream 字节流包装为其他流的过程就是装饰器模式，比如，包装为 FileInputStream、ByteArrayInputStream、PipedInputStream 等。

#### 6.拦截器过滤器监听器

过滤器->拦截器->监听器

过滤器:  客户端和服务器之间的一个滤网,可以格式化参数,过滤请求,修改响应

拦截器:  权限验证、解决乱码、操作日志记录、性能监控、异常处理

监听器: **帮助开发者监听web中的特定事件统计在线人数**统计网站访问量



生命周期不同,作用域不同,访问顺序不同



#### 7.说说**List,Set,Map**三者的区别?

**List(**对付顺序的好帮手**)**: List接口存储一组不唯一(可以有多个元素引用相同的对象)，有 序的对象

**Set(**注重独一无二的性质**):** 不允许重复的集合。不会有多个元素引用相同的对象。 

**Map(**用**Key**来搜索的专家**):** 使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相 同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。

#### 8.**Arraylist** 与 **LinkedList** 区别**?**

- 底层数据结构: Arraylist 底层使用的是 **Object** 数组;LinkedList 底层使用的是 双向链表
- 是否支持快速随机访问: LinkedList 不支持高效的随机元素访问，而 ArrayList 支 持。快速随机访问就是通过元素的序号快速获取元素对象

#### 9.**ArrayList** 的扩容机制吧

默认10个超过,就是当前容量，右移一位，即除以2,再加上当前容量. 在内存中开辟一个新的数组,然后复制过去

#### 10.**HashMap** 和 **Hashtable** 的区别

1. 线程是否安全: HashMap 是非线程安全的，HashTable 是线程安全的;HashTable 内部的方法 基本都经过synchronized 修饰。(如果你要保证线程安全的话就使用 ConcurrentHashMap 吧!);

2. 效率: 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被 淘汰，不要在代码中使用它;

3. 对**Null key** 和**Null value**的支持: HashMap 中，null 可以作为键，这样的键只有一个，可以 有一个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null， 直接抛出 NullPointerException。

4. 初始容量大小和每次扩充容量大小的不同 : 1创建时如果不指定容量初始值，Hashtable 默认 的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后 每次扩充，容量变为原来的2倍。2创建时如果给定了容量初始值，那么 Hashtable 会直接使用 你给定的大小，而 HashMap 会将其扩充为2的幂次方大小(HashMap 中的tableSizeFor()方 法保证，下面给出了源代码)。也就是说 HashMap 总是使用2的幂作为哈希表的大小,后面会介 绍到为什么是2的幂次方。

5. 底层数据结构: JDK1.8 以后的 HashMap 在解决哈希冲突时有了􏰀大的变化，当链表⻓度大于 阈值(默认为8)时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。

#### 11. **HashMap** 和 **HashSet**区别

HashSet 底层就是基于 HashMap 实现.一个存储键值对.一个存储对象

#### 12.Java中String，StringBuffer和StringBuilder的区别

|类型|变化|线程安全|使用场景|执行效率|
|---|---|---|---|--|
| String       | String 的值是不可变的，每次对String的操作都会生成新的String对象，效率低耗费大量内存空间，从而引起GC。 |线程安全|如果要操作少量的数据用 String|最慢|
| StringBuffer | 可变 |线程安全|多线程操作字符串缓冲区 下操作大量数据 = StringBuffer|比较慢|
| StringBuilder | 可变  |线程不安全|单线程操作字符串缓冲区 下操作大量数据 = StringBuilder|最快|

#### 13.**java单机并发控制**

最基础的：

1.同步方法synchronized

2.同步块synchronized

进阶的：

重入锁ReentrantLock

# Mysql

#### 1. MySQL常用存储引擎介绍

**MyISAm**

MyISAm引擎不支持事物，不支持外健， 优势是访问速度快，对事务完整性没有要求或者以select，insert为主的应用基本上可以用这个引擎来创建表，支持索引缓存,非聚簇索引,支持全文索引,支持表锁

**InnoDB**

InnoDB存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全，**支持事物，支持索引， 支持自动增长列，支持外键约束**，行级锁。该引擎将数据存储在集群索引中，所以减少了主键查询的I/O。

但是对比MyISAM引擎，写的处理效率会差一些，并且会占用更多的磁盘空间以保留数据和索引。

聚簇索引 ,不支持全文索引(5.7以后支持全文索引),但是可以通过插件支持,支持行锁

#### 2. 硬盘存储结构

**MyISAm**

.frm 表定义

.myd 数据存储(mydata)

.myi 索引(myindex)

**InnoDB**

.frm 表定义

.idb  数据和索引存储文件.数据以主键聚集存储,真正的数据都在叶子节点中

#### 3.索引结构

**聚簇索引**

> 就是数据和文件一起存储,表的顺序按照索引的顺序来存储的,也就是说索引的顺序和表中记录的物理顺序一致,像innoBD中的复合索引,前缀索引,唯一索引都是在聚簇索引的基础上建立的,也统称辅助索引

主键索引就是聚簇索引实现之一,如果你这个表没有定义主键,那么它就会选择一个唯一非空索引代替

如果没有.innoDB就会生成一个gen_clust_index的隐式的聚簇索引

聚簇索引他使用的是B+树,就是每个节点就是主键ID,B+树的最后一层就是叶子节点,存储的是真实数据

辅助索引在B+树中叶子节点存储的是主键ID,聚簇索引存储的是数据

**非聚簇索引**

> 因为表数据和索引分开存储的,所以表数据顺序和索引顺序无关

非聚簇索引他使用的是B+树,就是每个节点就是主键ID,B+树的最后一层就是叶子节点,叶子节点存储的就是数据的地址,然后通过数据地址去.myd去查找数据.



#### 4. 是什么是MVCC

多版本并发器,主要是提供数据库的并发性能.



#### 5.事务的四个特性

原子性,一致性,隔离性,持续性

1 、原子性。事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做

> Undo log实现

2 、一致性。事 务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统 运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。

> 

3 、隔离性。一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。

> 通过加锁,mvcc实现

4 、持续性。也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。

> Redo log实现

#### 6.事务出现的问题

**脏读**

事例：老板要给程序员发工资，程序员的工资是3.6万/月。但是发工资时老板不小心按错了数字，按成3.9万/月，该钱已经打到程序员的户口，但是事务还没有提交，就在这时，程序员去查看自己这个月的工资，发现比往常多了3千元，以为涨工资了非常高兴。但是老板及时发现了不对，马上回滚差点就提交了的事务，将数字改成3.6万再提交。

分析：实际程序员这个月的工资还是3.6万，但是程序员看到的是3.9万。他看到的是老板还没提交事务时的数据。这就是脏读。

**可重复读**

程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（程序员事务开启），收费系统事先检测到他的卡里有3.6万，就在这个时候！！程序员的妻子要把钱全部转出充当家用，并提交。当收费系统准备扣款时，再检测卡里的金额，发现已经没钱了（第二次检测金额当然要等待妻子转出金额事务提交完）。程序员就会很郁闷，明明卡里是有钱的…
分析：这就是读提交，若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但在这个事例中，出现了一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读。

**不可重复读**

事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他买单时（事务开启，不允许其他事务的UPDATE修改操作），收费系统事先检测到他的卡里有3.6万。这个时候他的妻子不能转出金额了。接下来收费系统就可以扣款了。

分析：重复读可以解决不可重复读问题。写到这里，应该明白的一点就是，不可重复读对应的是修改，即UPDATE操作。但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作。

**幻读**

程序员某一天去消费，花了2千元，然后他的妻子去查看他今天的消费记录（全表扫描FTS，妻子事务开启），看到确实是花了2千元，就在这个时候，程序员花了1万买了一部电脑，即新增INSERT了一条消费记录，并提交。当妻子打印程序员的消费记录清单时（妻子事务提交），发现花了1.2万元，似乎出现了幻觉，这就是幻读。

分析：重复读可以解决不可重复读问题。写到这里，应该明白的一点就是，不可重复读对应的是修改，即UPDATE操作。但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作。

事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。

#### 7.隔离级别

**读未提交**

> 就是一个事务可以读取另一个未提交事务的数据。





**读以提交**

> 就是一个事务要等另一个事务提交后才能读取数据。



**可重复读**

> 可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读



**串行化**



> 完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞



一般常用的就是读以提交,和可重复读

#### 8. 为什么使用B+树索引

1. hash索引是无序的,不能进行范围查找,不能进行排序.值不同,但是hash值相同,查找就比较麻烦了,那就相当于全表扫描

2. 平衡二叉树,树越高查找越久,回旋查找时间非常久

3. b树比平衡二叉树好,但是也存在回旋查找的问题

4. b+树比b树多了一个叶子节点,就是一个链表,把你所有的数据进行了一个链表的排序,从小到大排序.同时解决了回旋查找的问题,就是通过单线链表查找,这也就是排序的时候需要通过索引排序

#### 9.索引失效(主要针对联合索引)

1. 最佳左前缀法则(按照索引建立时的顺序)

2. 大于号会失效

3. like 索引会失效

4. or失效

5. in 失效

6. <>失效

7. Is null 

8. is not null

9. 还有函数

10. 以及计算(+,-,*,/)

11. 以及类型自动(手动)转换 5.7以后就可以了

    联合索引

    ![](https://gitee.com/yz0812/mypic/raw/master/mysql%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95.png)

    a字段顺序: 1,1,2,2,3,3

    b字段顺序:1,2,2,1,4,1,2

    最佳左前缀法则

    可以看到,b字段是不按照顺序排列的,这和我们联合字段排序一样,先按照第一个排序.

    因为第一个字段是有序的,可以通过第一个字段a定位指定位置,再通过二分查找到第二个字段b

    大于号右边会失效

    因为b+树是没有序,无确定a位置,即使确定了也无法通过二分查找到第二个条件

    like 索引会失效

    固定前缀不会失效,因为B+树查找是通过字符的前缀一个一个的查找.不固定是无法查找

#### 10.mysql 优化

1.Explain 查看

2.不使用select *,使用不到覆盖索引

3.必须like 中模糊查询,和前缀模糊查询,如果非要用,使用覆盖索引.

4.排序使用覆盖索引

#### 11.什么是覆盖索引

就是查询字段被索引覆盖

比如说我设置了一个联合索引ab

select 查询字段和where查询字段一致,比如说我select a,b两个字段,where里面也有ab两个字段

#### 12.mysql锁

**行锁**

避免脏读,比如说我们可以把mysql事务自动提交改成手动提交,然后修改一条数据,然后在打开一个窗口查询发现时没有修改的,因为我们还没有提交事务. 这个时候我们再修改也是一直处于一个等待的阻塞状态,这就是第一个锁还没有释放,锁竞争

**表锁**

索引失效由行锁转为表锁,锁住整个表

**间隙锁**

发生在范围查找,在这个访问内会被间隙锁住,无法插入,会阻塞

**查询锁状态**

```sql
show status like 'innodb_row_lock%'
```



#### 13.索引类型

1. Normal 普通索引

> 表示普通索引，大多数情况下都可以使用

2. Full Text 全文索引

> FULLTEXT 用于搜索很长一篇文章的时候，效果最好。用在比较短的文本，如果就一两行字的，普通的 INDEX 也可以。

3. 空间索引

> 空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MYISAM的表中创建


4. Unique 唯一索引

> 表示唯一的，不允许重复的索引，如果该字段信息保证不会重复例如身份证号用作索引时，可设置为unique 



#### 14.索引方法

1、BTREE（B树（可以是多叉树）） {主流使用}

2、HASH（key,value） 这种方式对范围查询支持得不是很好

（1）Hash 索引仅仅能满足”=”,”IN”和”<=>”查询，不能使用范围查询

（2）Hash 索引无法被用来避免数据的排序操作。

（3）Hash 索引不能利用部分索引键查询。

（4）Hash 索引在任何时候都不能避免表扫描。

（5）Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。

#### 15. 在实际操作过程中，应该选取表中哪些字段作为索引？

1．选择唯一性索引
2．为经常需要排序、分组和联合操作的字段建立索引
3．为常作为查询条件的字段建立索引
4．限制索引的数目
5．尽量使用数据量少的索引
6．尽量使用前缀来索引
7．删除不再使用或者很少使用的索引

8. 经常更新修改的字段不要建立索引（针对mysql说，因为字段更改同时索引就要重新建立，排序，而Orcale好像是有这样的机制字段值更改了，它不立刻建立索引，排序索引，而是根据更改个数，时间段去做平衡索引这件事的）

9．不推荐在同一列建多个索引

#### 16. SQL的执行过程

##### 执行连接器
开始执行这条sql时，会检查该语句是否有权限，若是没有权限就直接返回错误信息，有权限会进行下一步，校验权限的这一步是在图一的连接器进行的，对连接用户权限的校验。

执行检索内存
相连建立之后，履行查询语句的时候，会先行检索内存，Mysql会先行冗余这个sql与否履行过，以此Key-Value的形式平缓适用内存中，Key是检索预定，Value是结果集。

假如内存key遭击中，便会间接回到给客户端，假如没命中，便会履行后续的操作，完工之后亦会将结果内存上去，当下一次进行查询的时候也是如此的循环操作。

##### 执行分析器
分析器主要有两步：（1）词法分析（2）语法分析

词法分析主要执行提炼关键性字，比如select，提交检索的表，提交字段名，提交检索条件。语法分析主要执行辨别你输出的sql与否准确，是否合乎mysql的语法。

当Mysql没有命中内存的时候，接着执行的是 FROM student 负责把数据库的表文件加载到内存中去，WHERE age< 60，会把所示表中的数据进行过滤，取出符合条件的记录行，生成一张临时表，

##### 执行优化器
查询优化器会将解析树转化成执行计划。一条查询可以有多种执行方法，最后都是返回相同结果。优化器的作用就是找到这其中最好的执行计划。

生成执行计划的过程会消耗较多的时间，特别是存在许多可选的执行计划时。如果在一条SQL语句执行的过程中将该语句对应的最终执行计划进行缓存。

当相似的语句再次被输入服务器时，就可以直接使用已缓存的执行计划，从而跳过SQL语句生成执行计划的整个过程，进而可以提高语句的执行速度。


MySQL使用基于成本的查询优化器。它会尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最少的一个。

##### 执行执行器
由优化器生成得执行计划，交由执行器进行执行，执行器调用存储引擎得接口，存储引擎获取数据并返回，结束整个查询得过程。

这里之讲解了select的过程，对于update这些修改数据或者删除数据的操作，会涉及到事务，会使用两个日志模块，redo log和binlog日志。具体对这两个日志的介绍请看着一篇文章。

以前的Mysql的默认存储引擎MyISAM引擎是没redo log的，而现在的默认存储引擎InnoDB引擎便是透过redo 复杂度来拥护事务的，保证事务能够准确的回滚或者提交，保证事务的ACID。



### 17.Mysql什么时候写入数据比较慢

构建索引的过程.



### 18.批量往mysql导入1000万数据有什么方法？

1.  一条SQL语句插入多条数据  

2. 在事务中进行插入处理，切记不要1条数据提交一下，肯定要分批处理

3. 数据有序插入，是为了减少索引的维护压力

   


# Spring 

#### 1.spring事务失效的几种情况

spring本身就是使用aop,进行了切面增强,那么失效的原因就是就是这个aop不起作用了

1. 发生自调用,本类调用本类方法(自己调用自己本身就是this,不是代理类)

2. 不是public,如果非要使用在不是pulbic可以使用代理模式

3. 数据库不支持事务

4. 没有被spring管理

5. 异常被拦截catch

#### 2.单点登录

提供一个接口,然后传入对应用户信息,我们再判断这个用户信息,如果存在,在我这边实现认证,将认证信息存入session.然后返回页面







# SpringBoot

#### 1.什么是springboot 

用来简化spring应用的初始搭建以及开发过程 使用特定的方式来进行配置（properties或yml文件）创建独立的spring引用程序 main方法运行 嵌入的Tomcat 无需部署war文件 简化maven配置 自动配置spring添加对应功能starter自动化配置 答：spring boot来简化spring应用开发，约定大于配置，去繁从简，just run就能创建一个独立的，产品级别的应用
#### 2.Springboot 有哪些优点？
快速创建独立运行的spring项目与主流框架集成 -使用嵌入式的servlet容器，应用无需打包成war包-starters自动依赖与版本控制 -大量的自动配置，简化开发，也可修改默认值 -准生产环境的运行应用监控 -与云计算的天然集成

#### 3.bean的生命周期

1. 实例化：也就是new一个对象
2. 属性注入：Spring上下文对实例化的bean进行配置（IOC注入）
3. 设置beanId：如果实现BeanNameAware接口，调用setBeanName()方法设置ID
4. 调用BeanFactoryAware.setBeanFactory(setBeanFactory(BeanFactory)：传递的是Spring工厂自身
5. 调用ApplicationContextAware.setApplicationContext(ApplicationContext)：传入Spring上下文
6. 实例化之前调用：BeanPostProcessor(proser).postProcessBeforeInitialization(Object obj, String s)方法调用，
7. 实例化：如果在spring配置中还配置了init-method属性，会自动调用该初始化方法。
8. 实质化之后调用：如果关联BeanPostProcessor(proser)接口，调用postProcessAfterInitialization(Object obj, String s)方法，
7. bean的销毁：当bean不再被使用时，就会调用destroy()方法；
8. bean销毁调用方法：如果配置了destroy-method方法，会自动调用该方法；

#### 4.springboot自动装配原理

SpringBoot启动的时候通过@EnableAutoConfiguration中的@Import(EnableAutoConfigurationImportSelector.class)借助EnableAutoConfigurationImportSelector类，注解找到META-INF/spring.factories文件中的所有自动配置类,将所有符合条件的@Configuration配置都加载到Ioc容器，借助SpringFactoriesLoader工具类实现自动配置

![](https://gitee.com/yz0812/mypic/raw/master/20210625005502.png)



### 5.Springboot和spring的区别

做了一个自动化配置的东西,现在都流行云计算,docker这些容器技术发展起来了,云计算比较火,讲究弹性扩容,那我的应用就要尽量去轻量级,所以springboot 约定大于配置,原先有很多Xml文件,有了Springboot之后,这些文件并不说没有了,只是他很多东西,做成标准化配置,这样其实有利也有弊,利是这样起应用简单了,不好的地方,他的黑盒的程度越来越高,很多人都只是处于一个会用的状态

# SpringCloud

#### 1. 有哪些常用的组件

注册中心 eureka,nacos,远程调用feign,负载均衡 ribbon,网关 zuul,Gateway ,熔断降级Hystricsm,配置中心config service ,nacos

eureka就是注册中心,其他服务导入eureka client,然后注册到eureka server 中,Eureka client会每30秒向Eureka server 发送一次心跳请求，证明该客户端服务正常.当Eureka server90s内没有接受客户端服务正常，注册中心会认为该节点失效，会注销该实列 （从注册表中删除注册信息),一段时间内如果服务端统计到大量客户端没有发送心跳，则认为网络异常，进去自我保护机制，不在剔除没有发送心跳的客户端,当客户端恢复正常之后，服务端就会退出自我保护模式

负载均衡器 ribbon,主要是做请求分发的,有几种负载均衡策略,轮询策略,随机策略,可用过滤策略:  过滤掉连接失败的服务节点，并且过滤掉高并发的服务节点，然后从健康的服务节点中，使用轮询策略选出一个节点返回。,响应时间权重策略 根据响应时间，分配一个权重weight，响应时间越长，weight越小，被选中的可能性越低。 ,轮询失败重试策略 首先使用轮询策略进行负载均衡，如果轮询失败，则再使用轮询策略进行一次重试，相当于重试下一个节点，看下一个节点是否可用，如果再失败，则直接返回失败。,并发量最小可用策略

feign声明式 WebService 客户端,Feign可以与Eureka和Ribbon组合使用以支持负载均衡。

zuul,Gateway ,springcloud 由于每个服务都会有一个端口,端口多不方便管理和统一鉴权,和统一路由, zuul是奈飞推出的,而gateway是springcloud自己推出的,gateway性能更加强,内部实现了限流,负载均衡,扩展性更强,gateway支持异步

Hystrix 服务降级,拖底的

config service 统一配置中心

#### 2. eureka大概原理或者机制

其他服务导入eureka client,然后注册到eureka server 中,Eureka client会每30秒向Eureka server 发送一次心跳请求，证明该客户端服务正常.当Eureka server90s内没有接受客户端服务正常，注册中心会认为该节点失效，会注销该实列 （从注册表中删除注册信息),一段时间内如果服务端统计到大量客户端没有发送心跳，则认为网络异常，进去自我保护机制，不在剔除没有发送心跳的客户端,当客户端恢复正常之后，服务端就会退出自我保护模式

#### 3. 微服务优缺点

1. 微服务是松藕合的，无论是在开发阶段或部署阶段都是独立的。

2. 能够快速响应, 局部修改容易, 一个服务出现问题不会影响整个应用。

3. 易于和第三方应用系统集成, 支持使用不同的语言开发, 允许你利用融合最新技术。

4. 每个微服务都很小，足够内聚，足够小，代码容易理解。团队能够更关注自己的工作成果, 聚焦指定的业务功能或业务需求。

5. 开发简单、开发效率提高，一个服务可能就是专一的只干一件事, 能够被小团队单独开发，这个小团队可以是 2 到 5 人的开发人员组成。
   缺点
   
   缺点

1. 开发人员要处理分布式系统的复杂性
2. 多服务运维难度，随着服务的增加，运维的压力也在增大
3. 系统部署依赖
4. 服务间通信成本
5. 数据一致性
6. 系统集成测试
7. 性能监控....

#### 4. 服务雪崩

**服务雪崩**：当A调用微服务B，B调C，和其他微服务，这是扇出，当扇出链路上某个微服务调用响应时间过长或者不可用，对微服务的A的调用就会占用越来越多的系统资源，导致系统崩溃，所谓的雪崩效应

**服务熔断：**一般是某个服务异常引起的，相当于“保险丝”，当某个异常条件被触发，直接熔断整个服务，不是等到此服务超时

**服务降级：**降级一般是从整体负荷考虑，当某个服务熔断之后，服务器将不再被调用，客户端可自己准备一个本地的fallback回调，返回一个缺省值，虽然服务水平下降，当能用，比直接挂掉要强

#### 5.说一下你对分布式理解是什么样的？

分布式有好也有坏处

1. 微服务是松藕合的，无论是在开发阶段或部署阶段都是独立的。

2. 能够快速响应, 局部修改容易, 一个服务出现问题不会影响整个应用。

3. 易于和第三方应用系统集成, 支持使用不同的语言开发, 允许你利用融合最新技术。

4. 每个微服务都很小，足够内聚，足够小，代码容易理解。团队能够更关注自己的工作成果, 聚焦指定的业务功能或业务需求。

5. 开发简单、开发效率提高，一个服务可能就是专一的只干一件事, 能够被小团队单独开发，这个小团队可以是 2 到 5 人的开发人员组成。

> 缺点

1. 开发人员要处理分布式系统的复杂性
2. 多服务运维难度，随着服务的增加，运维的压力也在增大
3. 系统部署依赖
4. 服务间通信成本
5. 数据一致性
6. 系统集成测试
7. 性能监控....

#### 6.权限是怎么设计的？

[RBAC ](http://www.sojson.com/tag_rbac.html)是基于角色的访问控制（`Role-Based Access Control` ）,都是将权限赋予角色,然后人员绑定角色,这样的权限设计很清楚，管理起来很方便。

#### 7.jwt是什么

JSON Web Token（JWT）是一个非常轻巧的规范。这个规范允许我们使用 JWT 在用户和服务器之间传递安全可靠的信息。

JSON Web Token由三部分组成，它们之间用圆点(.)连接。这三部分分别是：

- Header

- Payload

- Signature

因此，一个典型的JWT看起来是这个样子的：

  > xxxxx.yyyyy.zzzzz

#### 8.Feign客户端的远程调用是怎么实现的?协议是什么？Hystrics熔断保护的实现原理？

在微服务启动时，Feign会进行包扫描，对加@FeignClient注解的接口，按照注解的规则，创建远程接口的本地JDK Proxy代理实例。然后，将这些本地Proxy代理实例，注入到Spring IOC容器中。当远程接口的方法被调用，由Proxy代理实例去完成真正的远程访问，并且返回结果。

tcp协议





# 网络

#### 1. tcp三次握手

工作过程
TCP标志位：
TCP共有6个标志位，分别是：

SYN(synchronous),建立联机。
ACK(acknowledgement),确认。
PSH(push),传输。
FIN(finish),结束。
RST(reset),重置。
URG(urgent),紧急。

三次握手建立连接阐述：
第一次握手：客户端要和服务端进行通信，首先要告知服务端一声，遂发出一个SYN=1的连接请求信号,“服务端哥哥，我想给你说说话”。

第二次握手：当服务端接收到客户端的连接请求，此时要给客户端一个确认信息，“我知道了（ACK）,我这边已经准备好了，你现在能连吗（SYN）”。

第三次握手：当客户端收到了服务端的确认连接信息后，要礼貌的告知一下服务端，“好的，咱们开始联通吧（ACK）”。

#### 2.tcp四次挥手

第一次挥手：双方交流的差不多了，此时客户端也已经结尾了，接下来要断开通信连接，所以告诉服务端“我说完了（FIN）”，此时自身形成等待结束连接的状态。

第二次挥手：服务端知道客户端已经没话说了，服务端此时还有两句心里话要给客户端说，“我知道你说完了（ACK），我再给你说两句，&*……%￥”。

第三次挥手：此时客户端洗耳恭听继续处于等待结束的状态，服务器端也说完了，自身此时处于等待关闭连接的状态，并对告诉客户端，“我说完了，咱们断了吧（FIN）”。

第四次挥手：客户端收知道服务端也说完了，也要告诉服务端一声（ACK），因为连接和断开要双方都按下关闭操作才能断开，客户端同时又为自己定义一个定时器，因为不知道刚才说的这句话能不能准确到达服务端（网络不稳定或者其他因素引起的网络原因），默认时间定为两个通信的最大时间之和，超出这个时间就默认服务器端已经接收到了自己的确认信息，此时客户端就关闭自身连接，服务器端一旦接收到客户端发来的确定通知就立刻关闭服务器端的连接。



# Redis



#### 1. 分布式锁实现

加锁实际上就是在redis中，给Key键设置一个值，为避免死锁，并给定一个过期时间。



#### 2. redis缓存击穿,缓存穿透,缓存雪崩

- 缓存穿透：

  key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会到数据源，从而可能压垮数据源。

  比如说我自己做了个网站,别特火爆,然后就动了某些人的蛋糕,他就利用缓存恶意攻击我,大家都知道数据库自增ID是从0开始的,他就用负数作为参数攻击我,

  我把数据全部丢到redis里面,redis里面并没有小于0的数据,redis查询不到数据,就会查询数据库,这样就会造成请求就会不断打到数据库上面.redis中间层并不能拦截到这样的情况,这个redis直接被这样的请求给穿透了.

  把查询出来的值和参数都放到redis

  把IP拉黑

  参数合法性校验

  解决办法布隆过滤器

> 布隆过滤器就是一个2进制向量,其实就是2进制数组,存储的都是0和1,主要作用就是判断这个数据在没有在这个数组,如果在就是1,不在就是0. 

> 布隆过滤器存储,比如说将一个holle放到布隆过滤器中,首先会经过三个hash方法,然后这三个hash方法通过计算会计算出三个hash值,再将hash值,以下标的方式存储修改到布隆过滤器中. 如果说第一个hash算出来的是3 ,那么就找到第三个下标修改为1.

> 布隆过滤器查询: 通过三个hash方法去生成hash值,然后再到对应下标查询,看看是不是1,如果都是1那么就是存在.

> 布隆过滤器是很难做删除操作的, 如果说我一个一个holle和你好,2个值,2个值都通过hash方法计算的值是2,都将下标2改为了1. 那么这个下标目前是代表了2个值,但是这些在实际生产环境中我们都不知道,所以我们都不知道一个hash值到底代表了几个值.所以一般都不做删除



> 第一个:优点就是它是又一串二进制数组组成的一串数据,占的空间小,

> 第二个:查询插入快,因为他是计算数据的hash值,再由hash值映射到数组的下标,基于数组的特性,他的查询插入很快.

> 第三个:安全性特别好,因为都是二进制

> 缺点

> 第一个: 不容易删除

> 第二个: 存在误判,就是其他数据经过hash方法算出来的hash值,映射到一样的下标.这个是布隆过滤器不可避免的. 不过谷歌的Guava工具类中已经实现了布隆过滤器,其中有一个误判率的参数,你可以设置误判率,但是误判率越小,计算的时间也就越长. 具体实现原理就是误判率越低,hash方法越多,所占内存越多



还有一种升级版,布谷鸟过滤器

![](https://gitee.com/yz0812/mypic/raw/master/20210605232152.png)



布谷鸟过滤器就是一个一维数组,应该都听过,鸠占鹊巢,布谷鸟过滤器就是这样,通过2个hash方法,计算出2个哈希值,然后选择一个空闲hash映射存储,如果再存储一个值,也通过计算得到下标2,那么就会把下标2,之前的数据提出来重新找一个位置,这就鸠占鹊巢. 但是这种情况可能会出现挤兑循环. 解决办法是给这个挤兑加个次数,然后进行扩容.或者是多加几个hash方法,在hash数组中在就有多个位置,还有就是增加座位,一个下标可以存储多个值,

布谷鸟过滤器和布隆过滤器都是牺牲了数据的精度,来换取大小

- 缓存击穿：key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。 

  redis分布式锁(就是只有一个线程能拿到这个请求,进入数据库,然后再将值写回到redis,其他线程等待后再去查询redis,里面就有值了)

  永不过期

- 缓存雪崩：当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统(比如DB)带来很大压力。

  解决方法: 

  就是key的失效时间随机一点,不要太集中.

  或者暴力一点不设置失效,然后直接修改

  还有就是用定时任务去刷这个缓存

#### 3.redis除了做缓存你们还做其他东西吗？

hash 可以做单点登陆

list做消息队列

和基于redis的分页

set可以做去重.

sortset 排行榜



#### 4. redis缓存和我们框架项目去做缓存，有什么其他区别(比如用map做缓存)？

第一速度快,redis可以处理每秒百万级的并发，是专业的缓存服

第二存储东西多,如果使用map做的话,存储数据多可能回导致内存溢出

第三redis可以持久化,map不行

第四redis有过期失效

#### 5.Redis的有哪些模式？
单机模式,集群,哨兵

#### 6.redis持久化

RDB  全量

(快照) 保存某个时间的全量数据快照

比如说300秒内提交了10条数据,就产生一次快照



AOF 增量

记录下出查询以外所有的变更数据库状态的指令

以append的形式追加保存到AOF文件中(增量)

RDB和AOF的优缺点
RDB优点：全量数据快照，文件小，恢复快
RDB缺点：无法保存最近一次快照之后的数据
AOF优点：可读性高，适合保存增量数据，数据不容易丢失
AOF缺点：文件大，恢复时间长
RDB-AOF混合持久化方式
BGSAVE做镜像全量持久化，AOF做增量持久化

#### 7. redis为什么这么快?

1. 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。
2. 数据结构简单，对数据操作也简单
3. 采用单线程，避免了不必要的上下文切换和竞争条件
4. 使用多路I/O复用模型，非阻塞IO

#### 9.redis数据类型

1. String 最大512M
2. hash
3. list
4. set
5.  Sorted sets
6. Bitmaps 位图,面向字节操作的集合,可以实现布隆过滤器(最大512M)
7. HyperLoglog 。主要适用场景是海量数据的计算。特点是速度快。占用空间小。
8. Geo  用于计算地理位置信息相关的一些功能。

#### 10. 双写一致性

延时双删策略

- 先删除缓存
- 再写数据库
- 异步等待一段时间后，再次淘汰缓存。（这里的时间设定主要是保证读请求结束，写请求可以删除读请求遭成的缓存脏数据，需要自行评估确定。）

# nginx

#### 1. 正向代理和反向代理的区别

正向代理类似一个跳板机，代理访问外部资源

比如我们国内访问谷歌，直接访问访问不到，我们可以通过一个正向代理服务器，请求发到代理服，代理服务器能够访问谷歌，这样由代理去谷歌取到返回数据，再返回给我们，这样我们就能访问谷歌了



反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器

#### 2. Nginx负载均衡策略

| 轮询               | 默认方式        |
| ------------------ | --------------- |
| weight             | 权重方式        |
| ip_hash            | 依据ip分配方式  |
| least_conn         | 最少连接方式    |
| fair（第三方）     | 响应时间方式    |
| url_hash（第三方） | 依据URL分配方式 |

# mybatis

#### 1.Mybatis缓存

一级缓存是指SQLSession,mybatis默认开启,执行相同的SQL查询时；第一次会去查询数据库，并写在缓存中，第二次会直接从缓存中取。当执行了增删改的操作，则SQLSession的缓存会被清空.

二级缓存是namespace级别的，Mybatis默认是没有开启二级缓存的。 需要在配置文件开启,然后在mapper.xml的方法加上cache标签,二级缓存容易导致脏读

#### 2.#{}和${}区别

\#{} : 采用预编译方式,可以防止SQL注入,这个是默认加上“”
${}: 采用直接赋值方式,无法阻止SQL注入攻击



### 3.Hibernate和Mybatis的区别

一个轻量级一个重量级,Mybatis的sql是可控的,一定要写sqlMqp,Hibernate是JPA这种动态生成SQL

# RabbitMq

#### 1.  什么是RabbitMQ？为什么使用RabbitMQ？

答：RabbitMQ是一款开源的，Erlang编写的，基于AMQP协议的，消息中间件；

可以用它来：解耦、异步、削峰。

#### 2、RabbitMQ有什么优缺点？

答：优点：解耦、异步、削峰；

缺点：降低了系统的稳定性：本来系统运行好好的，现在你非要加入个消息队列进去，那消息队列挂了，你的系统不是呵呵了。因此，系统可用性会降低；

增加了系统的复杂性：加入了消息队列，要多考虑很多方面的问题，比如：一致性问题、如何保证消息不被重复消费、如何保证消息可靠性传输等。因此，需要考虑的东西更多，复杂性增大。

 

#### 3、如何保证RabbitMQ消息的可靠传输？

答：消息不可靠的情况可能是消息丢失，劫持等原因；

丢失又分为：生产者丢失消息、消息列表丢失消息、消费者丢失消息；

 

生产者丢失消息：从生产者弄丢数据这个角度来看，RabbitMQ提供transaction和confirm模式来确保生产者不丢消息；

transaction机制就是说：发送消息前，开启事务（channel.txSelect()）,然后发送消息，如果发送过程中出现什么异常，事务就会回滚（channel.txRollback()）,如果发送成功则提交事务（channel.txCommit()）。然而，这种方式有个缺点：吞吐量下降；

confirm模式用的居多：一旦channel进入confirm模式，所有在该信道上发布的消息都将会被指派一个唯一的ID（从1开始），一旦消息被投递到所有匹配的队列之后；

rabbitMQ就会发送一个ACK给生产者（包含消息的唯一ID），这就使得生产者知道消息已经正确到达目的队列了；

如果rabbitMQ没能处理该消息，则会发送一个Nack消息给你，你可以进行重试操作。

 

消息队列丢数据：消息持久化。

处理消息队列丢数据的情况，一般是开启持久化磁盘的配置。

这个持久化配置可以和confirm机制配合使用，你可以在消息持久化磁盘后，再给生产者发送一个Ack信号。

这样，如果消息持久化磁盘之前，rabbitMQ阵亡了，那么生产者收不到Ack信号，生产者会自动重发。

那么如何持久化呢？

这里顺便说一下吧，其实也很容易，就下面两步

1. 将queue的持久化标识durable设置为true,则代表是一个持久的队列
2. 发送消息的时候将deliveryMode=2

这样设置以后，即使rabbitMQ挂了，重启后也能恢复数据

 

消费者丢失消息：消费者丢数据一般是因为采用了自动确认消息模式，改为手动确认消息即可！

消费者在收到消息之后，处理消息之前，会自动回复RabbitMQ已收到消息；

如果这时处理消息失败，就会丢失该消息；

解决方案：处理消息成功后，手动回复确认消息。



#### 4.如何保证RabbitMQ消息的顺序性？

单线程消费保证消息的顺序性；对消息进行编号，消费者处理消息是根据编号处理消息；



# 多线程

#### 1. 线程生命周期

当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，它要经过新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）和死亡（Dead）五种状态。尤其是当线程启动以后，它不能一直“霸占”着CPU独自运行，所以CPU需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换。

- 新建

  创建Thread类的一个实例（对象）时，此线程进入新建状态（未被启动）。

- 就绪

  线程已经被启动，正在等待被分配给CPU时间片，也就是说此时线程正在就绪队列中排队等候得到CPU资源

- 运行

  线程获得CPU资源正在执行任务（run()方法），此时除非此线程自动放弃CPU资源或者有优先级更高的线程进入，线程将一直运行到结束。

- 阻塞

  由于某种原因导致正在运行的线程让出CPU并暂停自己的执行，即进入堵塞状态。

  正在睡眠：用sleep(long t) 方法可使线程进入睡眠方式。一个睡眠着的线程在指定的时间过去可进入就绪状态。

  正在等待：调用wait()方法。（调用motify()方法回到就绪状态）

  被另一个线程所阻塞：调用suspend()方法。（调用resume()方法恢复）

- 死亡

  当线程执行完毕或被其它线程杀死，线程就进入死亡状态，这时线程不可能再进入就绪状态等待执行。

  自然终止：正常运行run()方法后终止

  异常终止：调用stop()方法让一个线程终止运行



#### 2.多线程实现方法

**方式一：继承Thread类的方式**

1. 创建一个继承于Thread类的子类
2. 重写Thread类中的run()：将此线程要执行的操作声明在run()
3. 创建Thread的子类的对象
4. 调用此对象的start():①启动线程 ②调用当前线程的run()方法

**方式二：实现Runnable接口的方式**

1. 创建一个实现Runnable接口的类
2. 实现Runnable接口中的抽象方法：run():将创建的线程要执行的操作声明在此方法中
3. 创建Runnable接口实现类的对象
4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象
5. 调用Thread类中的start():① 启动线程 ② 调用线程的run() --->调用Runnable接口实现类的run()

**方式三：实现Callable接口**

1. 与使用Runnable相比， Callable功能更强大些

2. 实现的call()方法相比run()方法，可以返回值

3. 方法可以抛出异常

4. 支持泛型的返回值

5. 需要借助FutureTask类，比如获取返回结果

**方式四: 线程池**



#### 3. 单例模式那个有线程安全问题，如何解决

  懒汉式有线程安全问题，如果多个线程同时进入方法，就会实例化多次对象，此时就不是单例模式了

  解决：同步或者上双重校验锁判断，以保证对象只被实例化过一次.

 

#### 4.线程池

1. 线程池顾名思义就是一个装线程的池子，可以降低资源的消耗--->通过重复利用已经创建的线程，降低线程创建和销毁对性能的影响
2. 提高响应速度，当任务到达时可以不需要等待线程创建就能立即执行
3. 提高线程的管理，线程创建和销毁统一管理，不回消耗过多的系统资源 

#### 5.线程池创建方式

1. newCachedThreadPool：一个可以无限扩大的线程池，适用于任务量比较大，但是任务执行时间很短，60s以内，不会造成CPU的过度切换（闪电战）
2. newFixedThreadPool：创建一个固定大小的线程池，适用于任务数量比较固定，并且执行时间比较长的任务（情感专家，长时间开导疗伤）
3. newSingleThreadExecutor：创建一个单线程的线程池，适用于需要保证顺序执行的任务（撩妹讲究认识的先后顺序，认识最早的妹子第一个聊）
4. newScheduledThreadPool：适用于执行延迟或者周期性的任务（隔壁老王喜欢每天六点固定去骚扰隔壁大婶）



#### 6. 线程池核心参数

1. 线程池的核心线程数 - 可以理解成线程池最少存在几个线程
2. 线程池的最大线程数 - 所允许存在的最多数量
3. 线程存活时间 - 线程池中的线程数大于核心线程数量的时候，线程的空闲时间如果超过这个设定值，线程就会被销毁，直到线程池中的线程数量小于或者等于核心线程数
4. 任务队列 - 用于保存那些等待执行的任务
5. 线程工厂 - 用于创建新的线程
6. 线程的饱和策略 - 当线程池和队列都满了的话，再加入进来的任务会执行哪种策略

#### 7.线程执行流程

当一个任务进来，判断线程池当前数量是否大于核心线程数，如果小于就创建一个新的线程来执行任务；如果大于就判断队列是否已经满了，没满的话将任务添加到工作队列里面，如果满了则判断当前线程池的线程数量是否大于最大线程数，如果小于则创建一个新的线程来执行任务，如果大于则执行饱和策略（比如拒绝策略）



#### 8.死锁如何发生，如何解决死锁

所谓死锁是指多个线程因竞争资源而造成的一种僵局(互相等待)，若无外力作用，这些进程都将无法向前推

 　1）加锁顺序(线程按照一定的顺序加锁

　2）加锁时限(线程获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁)



解决： 同步中尽量不要嵌套同步 

#### 9. run和start方法区别

调用start()方法会创建一个新的子线程并启动

run()方法只是Thread的一个普通方法的调用

#### 10.继承thread类和runable 的优缺点

 继承Thread类，实现多线程，相当于多个线程去分别执行自己的任务

 实现runable接口，相当于多个线程共同执行去完成一个任务

 这是两个不同的线程，虽然thread+同步也能达到runable的效果，

 外加java里有单继承多实现的限制自我感觉runable好一点



#### 11.Notfy,notfyall 区别

 Notify只会唤醒一个线程去执行代码，而notifyall会唤醒所有调用wait方法的线程，让这些线程从等待池进入锁池，然后去竞争锁，谁优先级高竞争到锁的概率越大



#### 12.wait和sleep的区别

1、这两个方法来自不同的类分别是Thread和Object

  2、最主要是sleep方法没有释放锁，而 wait 方法释放了锁，使得其他线程可以使用同步控制块或者方法。

  3、wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用（使用范围）

  4、sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常

  5、sleep(milliseconds)可以用时间指定来使他自动醒过来,如果时间不到你只能调用interreput()来强行打断;wait()可以用notify()直接唤起.



#### 13. Thread Runnable Callable区别

1.执行方法名称不同
Thread,Runnable的执行方法是run()，而Callable的执行方法是call()

2.有无返回值
Thread,Runnable的run方法是没有返回值的，而Callable的call方法是可以有返回值。

3.有无泛型
Thread,Runnable是没有携带泛型的，而Callable是可以携带泛型的
如：public class CallableThread implements Callable{}



#### 14.进程和线程的区别

1. 线程不能看作独立应用,而进程可以看作独立应用

2. 进程有独立的地址空间,相互不影响,线程只是进程不同的执行路径
3. 线程没有独立的地址空间,多进程的程序要比多线程的程序及健壮
4. 进行的切换比线程切换开销大



#### 15. Java 进程和线程的关系

1. java对操作系统提供的功能进行封装,包括进程和线程
2. 运行一个程序会产生一个进程,进程至少包含一个线程
3. 每个进程对应一个JVM实例,多个线程共享JVM堆
4. Java采用单线程编程,程序会自动创建主线程
5. 主线程可以创建子线程,原则是要后于子线程完成执行



#### 16.yieId

当调用Thread.yieId()函数时,会给线程调度器一个当前线程愿意让出CPU使用的暗示,但是线程调度器可能会忽略这个暗示



#### 17. synchronized和lock的区别

1、lock是一个接口，而synchronized是java的一个关键字。2、synchronized在发生异常时会自动释放占有的锁，因此不会出现死锁；而lock发生异常时，不会主动释放占有的锁，必须手动来释放锁，可能引起死锁的发生。

# JVM

#### 1.jvm如何加载.class

Class Loader:一句特定格式,加载class文件到内存

execution engine: 对命令进行解析

native Interface: 融合不同开发语言的原生库为java所用

Runtime Date Area: JVM内存空间结构模型



#### 2.反射

java放射机制是在运行状态中,对于任意一个类,都能知道这个类的所有属性和方法:对于任意个对象都能够调用他的任意方法和属性;这种动态获取信息,以及动态调用对象方法的功能称为java语言的反射机制

#### 3.类冲编译到执行的过程

1. 编译器将Robot.java源文件编译为Robot.class字节码文件

2. CLassloader将字节码转换为JVM中的Class<Robot>对象

3. JVM利用Class<Robot>对象实例化为Robot对象

   

#### 4. 谈谈ClassLoader 

classloader在java中有着非常重要的作用,它主要工作在class装载的加载阶段,其主要作用是从系统外部获得Class二进制数据流.它是java的核心组件,所有的class都是由ClassLoader进行加载的,classLoader负责通过将Class文件里面的二进制数据流装载进系统,然后交Java虚拟机进行连接,初始化等操作



#### 5.classloader种类

1. BootStrapClassLoder C++编写,加载核心库 java.*
2. ExtClassLoder Java编写,加载扩展库 Javax.*
3. AppClassLoder java编写,加载程序所在目录
4.  自定义classloader  java编写,定制化加载



#### 6.什么是双亲委派机制



#### 7.为什么要使用双亲委派机制

避免多份同样字节码的加载

#### 8.什么时候去打破双亲委派机制



#### 9.类的加载方式

隐式: new

显式: loadCLass,forName

#### 10.loadCLass,forName的区别



#### 11.JVM内存模型

线程私有: 程序计数器,虚拟机栈,本地方法栈

线程功效: matespace,java堆

#### 12. JVM三大性能调优参数 -Xms -Xmx -Xss

-Xms: 堆的初始值

-Xmx:堆的最大值

-Xss:每个线程虚拟机栈的大小

#### 13.Java内存模型中堆和栈的区别

管理方式: 栈自动释放,堆CG释放

空间大小: 栈比堆小

碎片相关: 栈产生的碎片远小于堆

分配方式: 栈支持静态和动态分配,而堆仅支持动态分配

效率: 栈的效率比堆高



#### 14.对象被判定为垃圾的标准

没有被其他对象引用



#### 15.垃圾回收算法

- 引用计算算法
  1.  通过判断对象的引用数量来决定对象释放可以被回收
  2. 每个对象实例都有一个引用计数器,被引用则+1,完成引用则-1
  3. 任何引用计数器为0的对象实例可以被当作垃圾收集

> 优点: 执行效率高,程序执行受影响较小
>
> 缺点: 无法检测出循环引用的情况,导致内存泄露



- 可达性分析算法

  通过判断对象的引用链是否可达来节点对象释放可以被回收

  可以作为GC Root的对象

  1. 虚拟机栈中引用的对象(栈帧中的本地变量表)
  2. 方法区中的常量引用对象
  3. 方法区中的类静态属性引用对象
  4. 本地方法栈中的JNI(Native方法)的引用对象
  5. 活跃线程的引用对象

- 复制算法
  1. 分为对象面和空闲面
  2. 对象在对象面上创建
  3. 存活的对象被从对象面复制知道空闲面
  4. 将对象面所有对象内存清除

> 解决了碎片化的问题
>
> 顺序分配内存,简单高效
>
> 适用于对象存活率低的场景

- 标记-整理算法

  1. 避免内存的不连续行
  2. 不用设置两块内存互换
  3. 适用于存活率高的场景

- 分代收集算法

  1. 垃圾回收算法的组合拳
  2. 按照对象生命周期的不同划分区域以采用不同的垃圾回收算法
  3. 目的:提高JVM的回收效率

  年轻代: 尽可能快速的收集掉那些生命周期短的对象

  1. Eden区
  2. 两个Survivor区

  如何晋升到老年代

  1. 经历一定minor次数依然存活的对象
  2. Survivor 区中存放不下的对象
  3. 新生产的大对象

  常用的调优参数

  ​	-XX:survivorRatio: Eden和survivor的比值,默认8:1

  ​	-XX:NewRatio: 老年代和年轻代内存大小的比例

  老年代

  ​	Full GC比Major GC 慢,但执行频率低

  触发Full GC的条件

  1. 老年代空间不足
  2. 永久代空间不足
  3. CMS GC出现promotion failed ,concurrent mode failure
  4. minor GC晋升到老年代的平均大小大雨老年代的剩余空间
  5. 调用System.gc()
  6. 使用RMI来进行RPC或者管理的JDK应用,每小时执行1次Full GC

#### 15.java中的强引用,软引用,弱引用,虚引用有什么用

​	一：强引用（Strong Reference)

最普遍的引用：Object obj=new Object()

抛出OutOfMemoryError终止程序也不会回收具有强引用的对象

通过将对象设置为null来弱化引用，使其被回收

​	二：软引用（Soft Reference)

对象处在有用但非必须的状态

只有当内存空间不足时，GC会回收该引用的对象的内存

可以用来实现告诉缓存

例如：String abc=new String("d");//强引用

SoftReference<String> softRef=new SoftReference<String>(abc);//软引用

​	三：弱引用（Weak Reference)

非必须的对象，比软引用更弱一些

GC时会被回收

被回收的概率也不大，因为GC线程优先级比较低

适用于引用偶尔被使用且不影响垃圾收集的对象

​	四：虚引用（Phantom Reference)

不会决定对象的生命周期

任何时候都可能被垃圾收集器回收

根据对象被垃圾回收器回收的活动，起哨兵的作用

必须和ReferenceQueue联合使用

